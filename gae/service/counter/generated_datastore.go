// Code generated by github.com/yssk22/go/generator DO NOT EDIT.
//
package counter

import (
	"context"
	ds "github.com/yssk22/go/gae/datastore"
	"github.com/yssk22/go/x/xerrors"
	"github.com/yssk22/go/x/xtime"
	"google.golang.org/appengine/datastore"
	"time"
)

func (s *Config) NewKey(ctx context.Context) *datastore.Key {
	return ds.NewKey(ctx, "CounterConfig", s.Key)
}

type ConfigReplacer interface {
	Replace(*Config, *Config) *Config
}

type ConfigReplacerFunc func(*Config, *Config) *Config

func (f ConfigReplacerFunc) Replace(old *Config, new *Config) *Config {
	return f(old, new)
}

type ConfigKind struct{}

func NewConfigKind() *ConfigKind {
	return configKindInstance
}

func (d *ConfigKind) Get(ctx context.Context, key interface{}, options ...ds.CRUDOption) (*datastore.Key, *Config, error) {
	keys, ents, err := d.GetMulti(ctx, []interface{}{key}, options...)
	if err != nil {
		return nil, nil, err
	}
	return keys[0], ents[0], nil
}

func (d *ConfigKind) MustGet(ctx context.Context, key interface{}, options ...ds.CRUDOption) (*datastore.Key, *Config) {
	k, v, e := d.Get(ctx, key, options...)
	xerrors.MustNil(e)
	return k, v
}

func (d *ConfigKind) GetMulti(ctx context.Context, keys interface{}, options ...ds.CRUDOption) ([]*datastore.Key, []*Config, error) {
	var err error
	var dsKeys []*datastore.Key
	var ents []*Config
	if dsKeys, err = ds.NormalizeKeys(ctx, "CounterConfig", keys); err != nil {
		return nil, nil, xerrors.Wrap(err, "could not normalize keys: %v", keys)
	}
	size := len(dsKeys)
	if size == 0 {
		return nil, nil, nil
	}
	ents = make([]*Config, size, size)
	if err = ds.GetMulti(ctx, dsKeys, ents, options...); err != nil {
		return nil, nil, err
	}
	return dsKeys, ents, nil
}

func (d *ConfigKind) MustGetMulti(ctx context.Context, keys interface{}, options ...ds.CRUDOption) ([]*datastore.Key, []*Config) {
	k, v, e := d.GetMulti(ctx, keys, options...)
	xerrors.MustNil(e)
	return k, v
}

func (d *ConfigKind) Put(ctx context.Context, ent *Config, options ...ds.CRUDOption) (*datastore.Key, error) {
	keys, err := d.PutMulti(ctx, []*Config{ent}, options...)
	if err != nil {
		return nil, err
	}
	return keys[0], nil
}

func (d *ConfigKind) MustPut(ctx context.Context, ent *Config, options ...ds.CRUDOption) *datastore.Key {
	k, e := d.Put(ctx, ent, options...)
	xerrors.MustNil(e)
	return k
}

func (d *ConfigKind) PutMulti(ctx context.Context, ents []*Config, options ...ds.CRUDOption) ([]*datastore.Key, error) {
	var err error
	var size = len(ents)
	var dsKeys []*datastore.Key
	dsKeys = make([]*datastore.Key, size, size)
	for i := range ents {
		dsKeys[i] = ents[i].NewKey(ctx)
		ents[i].UpdatedAt = xtime.Now()
	}
	if dsKeys, err = ds.PutMulti(ctx, dsKeys, ents); err != nil {
		return nil, err
	}
	return dsKeys, nil
}

func (d *ConfigKind) MustPutMulti(ctx context.Context, ents []*Config, options ...ds.CRUDOption) []*datastore.Key {
	keys, err := d.PutMulti(ctx, ents, options...)
	xerrors.MustNil(err)
	return keys
}

func (d *ConfigKind) Delete(ctx context.Context, key interface{}, options ...ds.CRUDOption) (*datastore.Key, error) {
	keys, err := d.DeleteMulti(ctx, []interface{}{key}, options...)
	if err != nil {
		return nil, err
	}
	return keys[0], nil
}

func (d *ConfigKind) MustDelete(ctx context.Context, key interface{}, options ...ds.CRUDOption) *datastore.Key {
	k, e := d.Delete(ctx, key, options...)
	xerrors.MustNil(e)
	return k
}

func (d *ConfigKind) DeleteMulti(ctx context.Context, keys interface{}, options ...ds.CRUDOption) ([]*datastore.Key, error) {
	var err error
	var dsKeys []*datastore.Key
	if dsKeys, err = ds.NormalizeKeys(ctx, "CounterConfig", keys); err != nil {
		return nil, xerrors.Wrap(err, "could not normalize keys: %v", keys)
	}
	size := len(dsKeys)
	if size == 0 {
		return nil, nil
	}
	if err = ds.DeleteMulti(ctx, dsKeys); err != nil {
		return nil, xerrors.Wrap(err, "datastore error")
	}
	return dsKeys, nil
}

func (d *ConfigKind) MustDeleteMulti(ctx context.Context, keys interface{}, options ...ds.CRUDOption) []*datastore.Key {
	k, e := d.DeleteMulti(ctx, keys, options...)
	xerrors.MustNil(e)
	return k
}

func (d *ConfigKind) DeleteMatched(ctx context.Context, q *ConfigQuery, options ...ds.CRUDOption) ([]*datastore.Key, error) {
	keys, err := q.query.KeysOnly().GetAll(ctx, nil)
	if err != nil {
		return nil, err
	}
	_, err = d.DeleteMulti(ctx, keys, options...)
	if err != nil {
		return nil, err
	}
	return keys, nil
}

func (d *ConfigKind) MustDeleteMatched(ctx context.Context, q *ConfigQuery, options ...ds.CRUDOption) []*datastore.Key {
	keys, err := d.DeleteMatched(ctx, q, options...)
	xerrors.MustNil(err)
	return keys
}

func (d *ConfigKind) Replace(ctx context.Context, ent *Config, replacer ConfigReplacer, options ...ds.CRUDOption) (*datastore.Key, *Config, error) {
	keys, ents, err := d.ReplaceMulti(ctx, []*Config{ent}, replacer, options...)
	if err != nil {
		return nil, ents[0], err
	}
	return keys[0], ents[0], err
}

func (d *ConfigKind) MustReplace(ctx context.Context, ent *Config, replacer ConfigReplacer, options ...ds.CRUDOption) (*datastore.Key, *Config) {
	k, v, e := d.Replace(ctx, ent, replacer, options...)
	xerrors.MustNil(e)
	return k, v
}

func (d *ConfigKind) ReplaceMulti(ctx context.Context, ents []*Config, replacer ConfigReplacer, options ...ds.CRUDOption) ([]*datastore.Key, []*Config, error) {
	var size = len(ents)
	var dsKeys = make([]*datastore.Key, size, size)
	if size == 0 {
		return dsKeys, ents, nil
	}
	for i := range ents {
		dsKeys[i] = ents[i].NewKey(ctx)
	}
	_, existing, err := d.GetMulti(ctx, dsKeys)
	if err != nil {
		return nil, ents, err
	}
	for i, exist := range existing {
		if exist != nil {
			ents[i] = replacer.Replace(exist, ents[i])
		}
	}
	dsKeys, err = d.PutMulti(ctx, ents)
	return dsKeys, ents, err
}

func (d *ConfigKind) MustReplaceMulti(ctx context.Context, ents []*Config, replacer ConfigReplacer, options ...ds.CRUDOption) ([]*datastore.Key, []*Config) {
	k, v, e := d.ReplaceMulti(ctx, ents, replacer, options...)
	xerrors.MustNil(e)
	return k, v
}

type ConfigQuery struct {
	query   *ds.Query
	viaKeys bool
}

func NewConfigQuery() *ConfigQuery {
	return &ConfigQuery{
		query:   ds.NewQuery("CounterConfig"),
		viaKeys: false,
	}
}

func (d *ConfigQuery) EqKey(v string) *ConfigQuery {
	d.query = d.query.Eq("Key", v)
	return d
}

func (d *ConfigQuery) EqNumShards(v int) *ConfigQuery {
	d.query = d.query.Eq("NumShards", v)
	return d
}

func (d *ConfigQuery) EqUpdatedAt(v time.Time) *ConfigQuery {
	d.query = d.query.Eq("UpdatedAt", v)
	return d
}

func (d *ConfigQuery) LtKey(v string) *ConfigQuery {
	d.query = d.query.Lt("Key", v)
	return d
}

func (d *ConfigQuery) LtNumShards(v int) *ConfigQuery {
	d.query = d.query.Lt("NumShards", v)
	return d
}

func (d *ConfigQuery) LtUpdatedAt(v time.Time) *ConfigQuery {
	d.query = d.query.Lt("UpdatedAt", v)
	return d
}

func (d *ConfigQuery) LeKey(v string) *ConfigQuery {
	d.query = d.query.Le("Key", v)
	return d
}

func (d *ConfigQuery) LeNumShards(v int) *ConfigQuery {
	d.query = d.query.Le("NumShards", v)
	return d
}

func (d *ConfigQuery) LeUpdatedAt(v time.Time) *ConfigQuery {
	d.query = d.query.Le("UpdatedAt", v)
	return d
}

func (d *ConfigQuery) GtKey(v string) *ConfigQuery {
	d.query = d.query.Gt("Key", v)
	return d
}

func (d *ConfigQuery) GtNumShards(v int) *ConfigQuery {
	d.query = d.query.Gt("NumShards", v)
	return d
}

func (d *ConfigQuery) GtUpdatedAt(v time.Time) *ConfigQuery {
	d.query = d.query.Gt("UpdatedAt", v)
	return d
}

func (d *ConfigQuery) GeKey(v string) *ConfigQuery {
	d.query = d.query.Ge("Key", v)
	return d
}

func (d *ConfigQuery) GeNumShards(v int) *ConfigQuery {
	d.query = d.query.Ge("NumShards", v)
	return d
}

func (d *ConfigQuery) GeUpdatedAt(v time.Time) *ConfigQuery {
	d.query = d.query.Ge("UpdatedAt", v)
	return d
}

func (d *ConfigQuery) NeKey(v string) *ConfigQuery {
	d.query = d.query.Ne("Key", v)
	return d
}

func (d *ConfigQuery) NeNumShards(v int) *ConfigQuery {
	d.query = d.query.Ne("NumShards", v)
	return d
}

func (d *ConfigQuery) NeUpdatedAt(v time.Time) *ConfigQuery {
	d.query = d.query.Ne("UpdatedAt", v)
	return d
}

func (d *ConfigQuery) AscKey() *ConfigQuery {
	d.query = d.query.Asc("Key")
	return d
}

func (d *ConfigQuery) AscNumShards() *ConfigQuery {
	d.query = d.query.Asc("NumShards")
	return d
}

func (d *ConfigQuery) AscUpdatedAt() *ConfigQuery {
	d.query = d.query.Asc("UpdatedAt")
	return d
}

func (d *ConfigQuery) DescKey() *ConfigQuery {
	d.query = d.query.Desc("Key")
	return d
}

func (d *ConfigQuery) DescNumShards() *ConfigQuery {
	d.query = d.query.Desc("NumShards")
	return d
}

func (d *ConfigQuery) DescUpdatedAt() *ConfigQuery {
	d.query = d.query.Desc("UpdatedAt")
	return d
}

func (d *ConfigQuery) Start(s string) *ConfigQuery {
	d.query = d.query.Start(s)
	return d
}

func (d *ConfigQuery) End(s string) *ConfigQuery {
	d.query = d.query.End(s)
	return d
}

func (d *ConfigQuery) Limit(n int) *ConfigQuery {
	d.query = d.query.Limit(n)
	return d
}

func (d *ConfigQuery) ViaKeys() *ConfigQuery {
	d.viaKeys = true
	return d
}

func (d *ConfigQuery) GetAll(ctx context.Context) ([]*datastore.Key, []Config, error) {
	if d.viaKeys {
		keys, err := d.query.KeysOnly().GetAll(ctx, nil)
		if err != nil {
			return nil, nil, err
		}
		_, ents, err := configKindInstance.GetMulti(ctx, keys)
		if err != nil {
			return nil, nil, err
		}
		list := make([]Config, len(ents))
		for i, e := range ents {
			list[i] = *e
		}
		return keys, list, nil
	}
	var ent []Config
	keys, err := d.query.GetAll(ctx, &ent)
	if err != nil {
		return nil, nil, err
	}
	return keys, ent, nil
}

func (d *ConfigQuery) MustGetAll(ctx context.Context) ([]*datastore.Key, []Config) {
	keys, ents, err := d.GetAll(ctx)
	xerrors.MustNil(err)
	return keys, ents
}

func (d *ConfigQuery) Count(ctx context.Context) (int, error) {
	return d.query.Count(ctx)
}

func (d *ConfigQuery) MustCount(ctx context.Context) int {
	c, err := d.query.Count(ctx)
	xerrors.MustNil(err)
	return c
}

func (d *ConfigQuery) Run(ctx context.Context) (*ConfigIterator, error) {
	iter, err := d.query.Run(ctx)
	if err != nil {
		return nil, err
	}
	return &ConfigIterator{
		ctx:     ctx,
		iter:    iter,
		viaKeys: d.viaKeys,
	}, err
}

func (d *ConfigQuery) MustRun(ctx context.Context) *ConfigIterator {
	iter, err := d.Run(ctx)
	xerrors.MustNil(err)
	return iter
}

func (d *ConfigQuery) RunAll(ctx context.Context) ([]datastore.Key, []Config, string, error) {
	iter, err := d.Run(ctx)
	if err != nil {
		return nil, nil, "", err
	}
	var keys []datastore.Key
	var ents []Config
	for {
		key, ent, err := iter.Next()
		if err != nil {
			return nil, nil, "", err
		}
		if ent == nil {
			cursor, err := iter.iter.Cursor()
			if err != nil {
				return nil, nil, "", err
			}
			return keys, ents, cursor.String(), nil
		}
		keys = append(keys, *key)
		ents = append(ents, *ent)
	}
}

func (d *ConfigQuery) MustRunAll(ctx context.Context) ([]datastore.Key, []Config, string) {
	keys, ents, next, err := d.RunAll(ctx)
	xerrors.MustNil(err)
	return keys, ents, next
}

type ConfigIterator struct {
	ctx     context.Context
	iter    *datastore.Iterator
	viaKeys bool
}

func (iter *ConfigIterator) Cursor() (datastore.Cursor, error) {
	return iter.iter.Cursor()
}

func (iter *ConfigIterator) MustCursor() datastore.Cursor {
	c, err := iter.iter.Cursor()
	xerrors.MustNil(err)
	return c
}

func (iter *ConfigIterator) Next() (*datastore.Key, *Config, error) {
	if iter.viaKeys {
		key, err := iter.iter.Next(nil)
		if err != nil {
			if err == datastore.Done {
				return nil, nil, nil
			}
			return nil, nil, err
		}
		_, ent, err := configKindInstance.Get(iter.ctx, key)
		if err != nil {
			return nil, nil, err
		}
		return key, ent, nil

	}
	var ent Config
	key, err := iter.iter.Next(&ent)
	if err != nil {
		if err == datastore.Done {
			return nil, nil, nil
		}
		return nil, nil, err
	}
	return key, &ent, nil
}

func (iter *ConfigIterator) MustNext() (*datastore.Key, *Config) {
	key, ent, err := iter.Next()
	xerrors.MustNil(err)
	return key, ent
}

var configKindInstance = &ConfigKind{}

func (s *Shard) NewKey(ctx context.Context) *datastore.Key {
	return ds.NewKey(ctx, "CounterShard", s.Key)
}

type ShardReplacer interface {
	Replace(*Shard, *Shard) *Shard
}

type ShardReplacerFunc func(*Shard, *Shard) *Shard

func (f ShardReplacerFunc) Replace(old *Shard, new *Shard) *Shard {
	return f(old, new)
}

type ShardKind struct{}

func NewShardKind() *ShardKind {
	return shardKindInstance
}

func (d *ShardKind) Get(ctx context.Context, key interface{}, options ...ds.CRUDOption) (*datastore.Key, *Shard, error) {
	keys, ents, err := d.GetMulti(ctx, []interface{}{key}, options...)
	if err != nil {
		return nil, nil, err
	}
	return keys[0], ents[0], nil
}

func (d *ShardKind) MustGet(ctx context.Context, key interface{}, options ...ds.CRUDOption) (*datastore.Key, *Shard) {
	k, v, e := d.Get(ctx, key, options...)
	xerrors.MustNil(e)
	return k, v
}

func (d *ShardKind) GetMulti(ctx context.Context, keys interface{}, options ...ds.CRUDOption) ([]*datastore.Key, []*Shard, error) {
	var err error
	var dsKeys []*datastore.Key
	var ents []*Shard
	if dsKeys, err = ds.NormalizeKeys(ctx, "CounterShard", keys); err != nil {
		return nil, nil, xerrors.Wrap(err, "could not normalize keys: %v", keys)
	}
	size := len(dsKeys)
	if size == 0 {
		return nil, nil, nil
	}
	ents = make([]*Shard, size, size)
	if err = ds.GetMulti(ctx, dsKeys, ents, options...); err != nil {
		return nil, nil, err
	}
	return dsKeys, ents, nil
}

func (d *ShardKind) MustGetMulti(ctx context.Context, keys interface{}, options ...ds.CRUDOption) ([]*datastore.Key, []*Shard) {
	k, v, e := d.GetMulti(ctx, keys, options...)
	xerrors.MustNil(e)
	return k, v
}

func (d *ShardKind) Put(ctx context.Context, ent *Shard, options ...ds.CRUDOption) (*datastore.Key, error) {
	keys, err := d.PutMulti(ctx, []*Shard{ent}, options...)
	if err != nil {
		return nil, err
	}
	return keys[0], nil
}

func (d *ShardKind) MustPut(ctx context.Context, ent *Shard, options ...ds.CRUDOption) *datastore.Key {
	k, e := d.Put(ctx, ent, options...)
	xerrors.MustNil(e)
	return k
}

func (d *ShardKind) PutMulti(ctx context.Context, ents []*Shard, options ...ds.CRUDOption) ([]*datastore.Key, error) {
	var err error
	var size = len(ents)
	var dsKeys []*datastore.Key
	dsKeys = make([]*datastore.Key, size, size)
	for i := range ents {
		dsKeys[i] = ents[i].NewKey(ctx)
		ents[i].UpdatedAt = xtime.Now()
	}
	if dsKeys, err = ds.PutMulti(ctx, dsKeys, ents); err != nil {
		return nil, err
	}
	return dsKeys, nil
}

func (d *ShardKind) MustPutMulti(ctx context.Context, ents []*Shard, options ...ds.CRUDOption) []*datastore.Key {
	keys, err := d.PutMulti(ctx, ents, options...)
	xerrors.MustNil(err)
	return keys
}

func (d *ShardKind) Delete(ctx context.Context, key interface{}, options ...ds.CRUDOption) (*datastore.Key, error) {
	keys, err := d.DeleteMulti(ctx, []interface{}{key}, options...)
	if err != nil {
		return nil, err
	}
	return keys[0], nil
}

func (d *ShardKind) MustDelete(ctx context.Context, key interface{}, options ...ds.CRUDOption) *datastore.Key {
	k, e := d.Delete(ctx, key, options...)
	xerrors.MustNil(e)
	return k
}

func (d *ShardKind) DeleteMulti(ctx context.Context, keys interface{}, options ...ds.CRUDOption) ([]*datastore.Key, error) {
	var err error
	var dsKeys []*datastore.Key
	if dsKeys, err = ds.NormalizeKeys(ctx, "CounterShard", keys); err != nil {
		return nil, xerrors.Wrap(err, "could not normalize keys: %v", keys)
	}
	size := len(dsKeys)
	if size == 0 {
		return nil, nil
	}
	if err = ds.DeleteMulti(ctx, dsKeys); err != nil {
		return nil, xerrors.Wrap(err, "datastore error")
	}
	return dsKeys, nil
}

func (d *ShardKind) MustDeleteMulti(ctx context.Context, keys interface{}, options ...ds.CRUDOption) []*datastore.Key {
	k, e := d.DeleteMulti(ctx, keys, options...)
	xerrors.MustNil(e)
	return k
}

func (d *ShardKind) DeleteMatched(ctx context.Context, q *ShardQuery, options ...ds.CRUDOption) ([]*datastore.Key, error) {
	keys, err := q.query.KeysOnly().GetAll(ctx, nil)
	if err != nil {
		return nil, err
	}
	_, err = d.DeleteMulti(ctx, keys, options...)
	if err != nil {
		return nil, err
	}
	return keys, nil
}

func (d *ShardKind) MustDeleteMatched(ctx context.Context, q *ShardQuery, options ...ds.CRUDOption) []*datastore.Key {
	keys, err := d.DeleteMatched(ctx, q, options...)
	xerrors.MustNil(err)
	return keys
}

func (d *ShardKind) Replace(ctx context.Context, ent *Shard, replacer ShardReplacer, options ...ds.CRUDOption) (*datastore.Key, *Shard, error) {
	keys, ents, err := d.ReplaceMulti(ctx, []*Shard{ent}, replacer, options...)
	if err != nil {
		return nil, ents[0], err
	}
	return keys[0], ents[0], err
}

func (d *ShardKind) MustReplace(ctx context.Context, ent *Shard, replacer ShardReplacer, options ...ds.CRUDOption) (*datastore.Key, *Shard) {
	k, v, e := d.Replace(ctx, ent, replacer, options...)
	xerrors.MustNil(e)
	return k, v
}

func (d *ShardKind) ReplaceMulti(ctx context.Context, ents []*Shard, replacer ShardReplacer, options ...ds.CRUDOption) ([]*datastore.Key, []*Shard, error) {
	var size = len(ents)
	var dsKeys = make([]*datastore.Key, size, size)
	if size == 0 {
		return dsKeys, ents, nil
	}
	for i := range ents {
		dsKeys[i] = ents[i].NewKey(ctx)
	}
	_, existing, err := d.GetMulti(ctx, dsKeys)
	if err != nil {
		return nil, ents, err
	}
	for i, exist := range existing {
		if exist != nil {
			ents[i] = replacer.Replace(exist, ents[i])
		}
	}
	dsKeys, err = d.PutMulti(ctx, ents)
	return dsKeys, ents, err
}

func (d *ShardKind) MustReplaceMulti(ctx context.Context, ents []*Shard, replacer ShardReplacer, options ...ds.CRUDOption) ([]*datastore.Key, []*Shard) {
	k, v, e := d.ReplaceMulti(ctx, ents, replacer, options...)
	xerrors.MustNil(e)
	return k, v
}

type ShardQuery struct {
	query   *ds.Query
	viaKeys bool
}

func NewShardQuery() *ShardQuery {
	return &ShardQuery{
		query:   ds.NewQuery("CounterShard"),
		viaKeys: false,
	}
}

func (d *ShardQuery) EqKey(v string) *ShardQuery {
	d.query = d.query.Eq("Key", v)
	return d
}

func (d *ShardQuery) EqCounterKey(v string) *ShardQuery {
	d.query = d.query.Eq("CounterKey", v)
	return d
}

func (d *ShardQuery) EqCount(v int) *ShardQuery {
	d.query = d.query.Eq("Count", v)
	return d
}

func (d *ShardQuery) EqUpdatedAt(v time.Time) *ShardQuery {
	d.query = d.query.Eq("UpdatedAt", v)
	return d
}

func (d *ShardQuery) LtKey(v string) *ShardQuery {
	d.query = d.query.Lt("Key", v)
	return d
}

func (d *ShardQuery) LtCounterKey(v string) *ShardQuery {
	d.query = d.query.Lt("CounterKey", v)
	return d
}

func (d *ShardQuery) LtCount(v int) *ShardQuery {
	d.query = d.query.Lt("Count", v)
	return d
}

func (d *ShardQuery) LtUpdatedAt(v time.Time) *ShardQuery {
	d.query = d.query.Lt("UpdatedAt", v)
	return d
}

func (d *ShardQuery) LeKey(v string) *ShardQuery {
	d.query = d.query.Le("Key", v)
	return d
}

func (d *ShardQuery) LeCounterKey(v string) *ShardQuery {
	d.query = d.query.Le("CounterKey", v)
	return d
}

func (d *ShardQuery) LeCount(v int) *ShardQuery {
	d.query = d.query.Le("Count", v)
	return d
}

func (d *ShardQuery) LeUpdatedAt(v time.Time) *ShardQuery {
	d.query = d.query.Le("UpdatedAt", v)
	return d
}

func (d *ShardQuery) GtKey(v string) *ShardQuery {
	d.query = d.query.Gt("Key", v)
	return d
}

func (d *ShardQuery) GtCounterKey(v string) *ShardQuery {
	d.query = d.query.Gt("CounterKey", v)
	return d
}

func (d *ShardQuery) GtCount(v int) *ShardQuery {
	d.query = d.query.Gt("Count", v)
	return d
}

func (d *ShardQuery) GtUpdatedAt(v time.Time) *ShardQuery {
	d.query = d.query.Gt("UpdatedAt", v)
	return d
}

func (d *ShardQuery) GeKey(v string) *ShardQuery {
	d.query = d.query.Ge("Key", v)
	return d
}

func (d *ShardQuery) GeCounterKey(v string) *ShardQuery {
	d.query = d.query.Ge("CounterKey", v)
	return d
}

func (d *ShardQuery) GeCount(v int) *ShardQuery {
	d.query = d.query.Ge("Count", v)
	return d
}

func (d *ShardQuery) GeUpdatedAt(v time.Time) *ShardQuery {
	d.query = d.query.Ge("UpdatedAt", v)
	return d
}

func (d *ShardQuery) NeKey(v string) *ShardQuery {
	d.query = d.query.Ne("Key", v)
	return d
}

func (d *ShardQuery) NeCounterKey(v string) *ShardQuery {
	d.query = d.query.Ne("CounterKey", v)
	return d
}

func (d *ShardQuery) NeCount(v int) *ShardQuery {
	d.query = d.query.Ne("Count", v)
	return d
}

func (d *ShardQuery) NeUpdatedAt(v time.Time) *ShardQuery {
	d.query = d.query.Ne("UpdatedAt", v)
	return d
}

func (d *ShardQuery) AscKey() *ShardQuery {
	d.query = d.query.Asc("Key")
	return d
}

func (d *ShardQuery) AscCounterKey() *ShardQuery {
	d.query = d.query.Asc("CounterKey")
	return d
}

func (d *ShardQuery) AscCount() *ShardQuery {
	d.query = d.query.Asc("Count")
	return d
}

func (d *ShardQuery) AscUpdatedAt() *ShardQuery {
	d.query = d.query.Asc("UpdatedAt")
	return d
}

func (d *ShardQuery) DescKey() *ShardQuery {
	d.query = d.query.Desc("Key")
	return d
}

func (d *ShardQuery) DescCounterKey() *ShardQuery {
	d.query = d.query.Desc("CounterKey")
	return d
}

func (d *ShardQuery) DescCount() *ShardQuery {
	d.query = d.query.Desc("Count")
	return d
}

func (d *ShardQuery) DescUpdatedAt() *ShardQuery {
	d.query = d.query.Desc("UpdatedAt")
	return d
}

func (d *ShardQuery) Start(s string) *ShardQuery {
	d.query = d.query.Start(s)
	return d
}

func (d *ShardQuery) End(s string) *ShardQuery {
	d.query = d.query.End(s)
	return d
}

func (d *ShardQuery) Limit(n int) *ShardQuery {
	d.query = d.query.Limit(n)
	return d
}

func (d *ShardQuery) ViaKeys() *ShardQuery {
	d.viaKeys = true
	return d
}

func (d *ShardQuery) GetAll(ctx context.Context) ([]*datastore.Key, []Shard, error) {
	if d.viaKeys {
		keys, err := d.query.KeysOnly().GetAll(ctx, nil)
		if err != nil {
			return nil, nil, err
		}
		_, ents, err := shardKindInstance.GetMulti(ctx, keys)
		if err != nil {
			return nil, nil, err
		}
		list := make([]Shard, len(ents))
		for i, e := range ents {
			list[i] = *e
		}
		return keys, list, nil
	}
	var ent []Shard
	keys, err := d.query.GetAll(ctx, &ent)
	if err != nil {
		return nil, nil, err
	}
	return keys, ent, nil
}

func (d *ShardQuery) MustGetAll(ctx context.Context) ([]*datastore.Key, []Shard) {
	keys, ents, err := d.GetAll(ctx)
	xerrors.MustNil(err)
	return keys, ents
}

func (d *ShardQuery) Count(ctx context.Context) (int, error) {
	return d.query.Count(ctx)
}

func (d *ShardQuery) MustCount(ctx context.Context) int {
	c, err := d.query.Count(ctx)
	xerrors.MustNil(err)
	return c
}

func (d *ShardQuery) Run(ctx context.Context) (*ShardIterator, error) {
	iter, err := d.query.Run(ctx)
	if err != nil {
		return nil, err
	}
	return &ShardIterator{
		ctx:     ctx,
		iter:    iter,
		viaKeys: d.viaKeys,
	}, err
}

func (d *ShardQuery) MustRun(ctx context.Context) *ShardIterator {
	iter, err := d.Run(ctx)
	xerrors.MustNil(err)
	return iter
}

func (d *ShardQuery) RunAll(ctx context.Context) ([]datastore.Key, []Shard, string, error) {
	iter, err := d.Run(ctx)
	if err != nil {
		return nil, nil, "", err
	}
	var keys []datastore.Key
	var ents []Shard
	for {
		key, ent, err := iter.Next()
		if err != nil {
			return nil, nil, "", err
		}
		if ent == nil {
			cursor, err := iter.iter.Cursor()
			if err != nil {
				return nil, nil, "", err
			}
			return keys, ents, cursor.String(), nil
		}
		keys = append(keys, *key)
		ents = append(ents, *ent)
	}
}

func (d *ShardQuery) MustRunAll(ctx context.Context) ([]datastore.Key, []Shard, string) {
	keys, ents, next, err := d.RunAll(ctx)
	xerrors.MustNil(err)
	return keys, ents, next
}

type ShardIterator struct {
	ctx     context.Context
	iter    *datastore.Iterator
	viaKeys bool
}

func (iter *ShardIterator) Cursor() (datastore.Cursor, error) {
	return iter.iter.Cursor()
}

func (iter *ShardIterator) MustCursor() datastore.Cursor {
	c, err := iter.iter.Cursor()
	xerrors.MustNil(err)
	return c
}

func (iter *ShardIterator) Next() (*datastore.Key, *Shard, error) {
	if iter.viaKeys {
		key, err := iter.iter.Next(nil)
		if err != nil {
			if err == datastore.Done {
				return nil, nil, nil
			}
			return nil, nil, err
		}
		_, ent, err := shardKindInstance.Get(iter.ctx, key)
		if err != nil {
			return nil, nil, err
		}
		return key, ent, nil

	}
	var ent Shard
	key, err := iter.iter.Next(&ent)
	if err != nil {
		if err == datastore.Done {
			return nil, nil, nil
		}
		return nil, nil, err
	}
	return key, &ent, nil
}

func (iter *ShardIterator) MustNext() (*datastore.Key, *Shard) {
	key, ent, err := iter.Next()
	xerrors.MustNil(err)
	return key, ent
}

var shardKindInstance = &ShardKind{}
