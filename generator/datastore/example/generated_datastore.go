// Code generated by github.com/yssk22/go/generator DO NOT EDIT.
//
package example

import (
	"context"
	ds "github.com/yssk22/go/gae/datastore"
	"github.com/yssk22/go/gae/memcache"
	"github.com/yssk22/go/x/xerrors"
	"github.com/yssk22/go/x/xtime"
	"google.golang.org/appengine"
	"google.golang.org/appengine/datastore"
)

func (s *Entity) NewKey(ctx context.Context) *datastore.Key {
	return ds.NewKey(ctx, "Entity", s.ID)
}

type EntityReplacer interface {
	Replace(*Entity, *Entity) *Entity
}

type EntityReplacerFunc func(*Entity, *Entity) *Entity

func (f EntityReplacerFunc) Replace(old *Entity, new *Entity) *Entity {
	return f(old, new)
}

type EntityDatastore interface {
	Get(context.Context, interface{}, ...ds.Option) (*datastore.Key, *Entity, error)
	MustGet(context.Context, interface{}, ...ds.Option) (*datastore.Key, *Entity)
	GetMulti(context.Context, interface{}, ...ds.Option) ([]*datastore.Key, []*Entity, error)
	MustGetMulti(context.Context, interface{}, ...ds.Option) ([]*datastore.Key, []*Entity)

	Put(context.Context, *Entity, ...ds.Option) (*datastore.Key, error)
	MustPut(context.Context, *Entity, ...ds.Option) *datastore.Key
	PutMulti(context.Context, []*Entity, ...ds.Option) ([]*datastore.Key, error)
	MustPutMulti(context.Context, []*Entity, ...ds.Option) []*datastore.Key

	Delete(context.Context, interface{}, ...ds.Option) (*datastore.Key, error)
	MustDelete(context.Context, interface{}, ...ds.Option) *datastore.Key
	DeleteMulti(context.Context, interface{}, ...ds.Option) ([]*datastore.Key, error)
	MustDeleteMulti(context.Context, interface{}, ...ds.Option) []*datastore.Key

	Replace(context.Context, *Entity, EntityReplacer, ...ds.Option) (*datastore.Key, *Entity, error)
	MustReplace(context.Context, *Entity, EntityReplacer, ...ds.Option) (*datastore.Key, *Entity)
	ReplaceMulti(context.Context, []*Entity, EntityReplacer, ...ds.Option) ([]*datastore.Key, []*Entity, error)
	MustReplaceMulti(context.Context, []*Entity, EntityReplacer, ...ds.Option) ([]*datastore.Key, []*Entity)
}

func GetEntityDatastore() EntityDatastore {
	return entityInstance
}

type entityDatastore struct{}

func (d *entityDatastore) Get(ctx context.Context, key interface{}, options ...ds.Option) (*datastore.Key, *Entity, error) {
	keys, ents, err := d.GetMulti(ctx, []interface{}{key}, options...)
	if err != nil {
		return nil, nil, err
	}
	return keys[0], ents[0], nil
}

func (d *entityDatastore) MustGet(ctx context.Context, key interface{}, options ...ds.Option) (*datastore.Key, *Entity) {
	k, v, e := d.Get(ctx, key, options...)
	xerrors.MustNil(e)
	return k, v
}

func (d *entityDatastore) GetMulti(ctx context.Context, keys interface{}, options ...ds.Option) ([]*datastore.Key, []*Entity, error) {
	var err error
	var dsKeys []*datastore.Key
	var memKeys []string
	var ents []*Entity

	opts := ds.NewCRUDOption(options...)
	if opts.Namespace != nil {
		ctx, err = appengine.Namespace(ctx, *(opts.Namespace))
		if err != nil {
			return nil, nil, xerrors.Wrap(err, "cannot enforce namespace")
		}
	}

	if dsKeys, err = ds.NormalizeKeys(ctx, "Entity", keys); err != nil {
		return nil, nil, xerrors.Wrap(err, "could not normalize keys: %v", keys)
	}

	size := len(dsKeys)
	if size == 0 {
		return nil, nil, nil
	}

	ents = make([]*Entity, size, size)
	// fetch from cache
	if !opts.NoCache {
		memKeys = make([]string, size, size)
		for i := range dsKeys {
			memKeys[i] = ds.GetMemcacheKey(dsKeys[i])
		}
		err = memcache.GetMulti(ctx, memKeys, ents)
		if err == nil {
			// Hit caches on all keys!!
			return dsKeys, ents, nil
		}
	}

	key2Idx := make(map[*datastore.Key]int)
	cacheMissingKeys := make([]*datastore.Key, 0)
	for i := range ents {
		if ents[i] == nil {
			key2Idx[dsKeys[i]] = i
			cacheMissingKeys = append(cacheMissingKeys, dsKeys[i])
		}
	}
	cacheMissingSize := len(cacheMissingKeys)
	cacheMissingEnts := make([]*Entity, cacheMissingSize, cacheMissingSize)
	if err = ds.GetMulti(ctx, cacheMissingKeys, cacheMissingEnts); ds.IsDatastoreError(err) {
		// we return nil even some ents hits the cache.
		return nil, nil, xerrors.Wrap(err, "datastore error")
	}
	for i := range cacheMissingKeys {
		entIdx := key2Idx[cacheMissingKeys[i]]
		ents[entIdx] = cacheMissingEnts[i]
	}

	// udpate cache
	if !opts.NoCache {
		cacheEnts := make([]*Entity, 0)
		cacheKeys := make([]string, 0)
		for i := range ents {
			if ents[i] != nil {
				cacheEnts = append(cacheEnts, ents[i])
				cacheKeys = append(cacheKeys, memKeys[i])
			}
		}
		if len(cacheEnts) > 0 {
			if err := memcache.SetMulti(ctx, cacheKeys, cacheEnts); err != nil {
			}
		}
	}

	return dsKeys, ents, nil
}

func (d *entityDatastore) MustGetMulti(ctx context.Context, keys interface{}, options ...ds.Option) ([]*datastore.Key, []*Entity) {
	k, v, e := d.GetMulti(ctx, keys, options...)
	xerrors.MustNil(e)
	return k, v
}

func (d *entityDatastore) Put(ctx context.Context, ent *Entity, options ...ds.Option) (*datastore.Key, error) {
	keys, err := d.PutMulti(ctx, []*Entity{ent}, options...)
	if err != nil {
		return nil, err
	}
	return keys[0], nil
}

func (d *entityDatastore) MustPut(ctx context.Context, ent *Entity, options ...ds.Option) *datastore.Key {
	k, e := d.Put(ctx, ent, options...)
	xerrors.MustNil(e)
	return k
}

func (d *entityDatastore) PutMulti(ctx context.Context, ents []*Entity, options ...ds.Option) ([]*datastore.Key, error) {
	var err error
	var size = len(ents)
	var dsKeys []*datastore.Key
	if size == 0 {
		return nil, nil
	}
	if size >= ds.MaxEntitiesPerUpdate {
		return nil, ds.ErrTooManyEnts
	}
	opts := ds.NewCRUDOption(options...)
	if opts.Namespace != nil {
		ctx, err = appengine.Namespace(ctx, *(opts.Namespace))
		if err != nil {
			return nil, xerrors.Wrap(err, "cannot enforce namespace")
		}
	}

	dsKeys = make([]*datastore.Key, size, size)
	for i := range ents {
		dsKeys[i] = ents[i].NewKey(ctx)
	}

	if !opts.NoTimestampUpdate {
		for i := range ents {
			ents[i].UpdatedAt = xtime.Now()
		}
	}

	if _, err = ds.PutMulti(ctx, dsKeys, ents); ds.IsDatastoreError(err) {
		return nil, xerrors.Wrap(err, "datastore error")
	}

	if !opts.NoCache {
		memKeys := make([]string, size, size)
		for i := range memKeys {
			memKeys[i] = ds.GetMemcacheKey(dsKeys[i])
		}
		if err := memcache.DeleteMulti(ctx, memKeys); memcache.IsMemcacheError(err) {
		}
	}

	return dsKeys, nil
}

func (d *entityDatastore) MustPutMulti(ctx context.Context, ents []*Entity, options ...ds.Option) []*datastore.Key {
	keys, err := d.PutMulti(ctx, ents, options...)
	xerrors.MustNil(err)
	return keys
}

func (d *entityDatastore) Delete(ctx context.Context, key interface{}, options ...ds.Option) (*datastore.Key, error) {
	keys, err := d.DeleteMulti(ctx, []interface{}{key}, options...)
	if err != nil {
		return nil, err
	}
	return keys[0], nil
}

func (d *entityDatastore) MustDelete(ctx context.Context, key interface{}, options ...ds.Option) *datastore.Key {
	k, e := d.Delete(ctx, key, options...)
	xerrors.MustNil(e)
	return k
}

func (d *entityDatastore) DeleteMulti(ctx context.Context, keys interface{}, options ...ds.Option) ([]*datastore.Key, error) {
	var err error
	var dsKeys []*datastore.Key

	opts := ds.NewCRUDOption(options...)
	if opts.Namespace != nil {
		ctx, err = appengine.Namespace(ctx, *(opts.Namespace))
		if err != nil {
			return nil, xerrors.Wrap(err, "cannot enforce namespace")
		}
	}

	if dsKeys, err = ds.NormalizeKeys(ctx, "Entity", keys); err != nil {
		return nil, xerrors.Wrap(err, "could not normalize keys: %v", keys)
	}

	size := len(dsKeys)
	if size == 0 {
		return nil, nil
	}
	if size >= ds.MaxEntitiesPerUpdate {
		return nil, ds.ErrTooManyEnts
	}

	if err = ds.DeleteMulti(ctx, dsKeys); ds.IsDatastoreError(err) {
		// we return nil even some ents hits the cache.
		return nil, xerrors.Wrap(err, "datastore error")
	}

	// invalidate cache
	if !opts.NoCache {
		memKeys := make([]string, size, size)
		for i := range memKeys {
			memKeys[i] = ds.GetMemcacheKey(dsKeys[i])
		}
		if err = memcache.DeleteMulti(ctx, memKeys); memcache.IsMemcacheError(err) {
		}
	}

	return dsKeys, nil
}

func (d *entityDatastore) MustDeleteMulti(ctx context.Context, keys interface{}, options ...ds.Option) []*datastore.Key {
	k, e := d.DeleteMulti(ctx, keys, options...)
	xerrors.MustNil(e)
	return k
}

func (d *entityDatastore) Replace(ctx context.Context, ent *Entity, replacer EntityReplacer, options ...ds.Option) (*datastore.Key, *Entity, error) {
	keys, ents, err := d.ReplaceMulti(ctx, []*Entity{ent}, replacer, options...)
	if err != nil {
		return nil, ents[0], err
	}
	return keys[0], ents[0], err
}

func (d *entityDatastore) MustReplace(ctx context.Context, ent *Entity, replacer EntityReplacer, options ...ds.Option) (*datastore.Key, *Entity) {
	k, v, e := d.Replace(ctx, ent, replacer, options...)
	xerrors.MustNil(e)
	return k, v
}

func (d *entityDatastore) ReplaceMulti(ctx context.Context, ents []*Entity, replacer EntityReplacer, options ...ds.Option) ([]*datastore.Key, []*Entity, error) {
	var size = len(ents)
	var dsKeys = make([]*datastore.Key, size, size)
	if size == 0 {
		return dsKeys, ents, nil
	}
	for i := range ents {
		dsKeys[i] = ents[i].NewKey(ctx)
	}
	_, existing, err := d.GetMulti(ctx, dsKeys)
	if err != nil {
		return nil, ents, err
	}
	for i, exist := range existing {
		if exist != nil {
			ents[i] = replacer.Replace(exist, ents[i])
		}
	}
	dsKeys, err = d.PutMulti(ctx, ents)
	return dsKeys, ents, err
}

func (d *entityDatastore) MustReplaceMulti(ctx context.Context, ents []*Entity, replacer EntityReplacer, options ...ds.Option) ([]*datastore.Key, []*Entity) {
	k, v, e := d.ReplaceMulti(ctx, ents, replacer, options...)
	xerrors.MustNil(e)
	return k, v
}

var entityInstance = &entityDatastore{}
