package main

const codeTemplate = `// Code generated by "ent -type={{.Type}}"; DO NOT EDIT

package {{.Package}}

import(
    {{range $key, $as := .Dependencies -}}
    {{if $as -}}
    {{$as}} "{{$key}}"
    {{else -}}
    "{{$key}}"
    {{end -}}
    {{end }}
)

func (ent *{{.Type}}) NewKey(ctx context.Context) *datastore.Key {
    return helper.NewKey(ctx, "{{.Type}}", ent.{{.IDField}})
}

type {{.Type}}Kind struct {
    useDefaultIfNil bool
    noCache bool
}

const {{.Type}}KindLoggerKey = "ent.{{snakecase .Type}}"

func (k *{{.Type}}Kind) New() *{{.Type}} {
    a := &{{.Type}}{}
    {{range .Fields -}}{{if .Default -}}
    a.{{.FieldName}} = {{.Default}}
    {{end}}{{end -}}
    return a
}

func (k *{{.Type}}Kind) UseDefaultIfNil(b bool) *{{.Type}}Kind {
    k.useDefaultIfNil = b
    return k
}

// Get gets the kind entity from datastore
func (k *{{.Type}}Kind) Get(ctx context.Context, key interface{}) (*datastore.Key, *{{.Type}}, error) {
    keys, ents, err := k.GetMulti(ctx, key)
    if err != nil {
        return nil, nil, err
    }
    return keys[0], ents[0], nil
}

// MustGet is like Get but returns only values and panic if error happens.
func (k *{{.Type}}Kind) MustGet(ctx context.Context, key interface{}) *{{.Type}} {
    _, v, err := k.Get(ctx, key)
    if err != nil {
        panic(err)
    }
    return v
}

// GetMulti do Get with multiple keys
func (k *{{.Type}}Kind) GetMulti(ctx context.Context, keys ...interface{}) ([]*datastore.Key, []*{{.Type}}, error) {
    logger := xlog.WithContext(ctx).WithKey({{.Type}}KindLoggerKey)
    size := len(keys)
    if size == 0 {
        return nil, nil, nil
    }
    var memKeys []string
    var dsKeys  []*datastore.Key
    var ents []*{{.Type}}

    dsKeys = make([]*datastore.Key, size, size)
    for i := range keys {
        dsKeys[i] = helper.NewKey(ctx, "{{.Type}}", keys[i])
    }
    ents = make([]*{{.Type}}, size, size)
    // Memcache access
    if !k.noCache {
        logger.Debugf("Trying to get entities from memcache...")
        memKeys = make([]string, size, size)
        for i := range dsKeys {
            memKeys[i] = ent.GetMemcacheKey(dsKeys[i])
        }
        err := memcache.GetMulti(ctx, memKeys, ents)
        if err == nil {
            // Hit caches on all keys!!
            return dsKeys, ents, nil
        }
        logger.Debug(func(p *xlog.Printer){
            p.Println("{{.Type}}#GetMulti [Memcache]", )
            for i:=0; i < size; i++ {
                s := fmt.Sprintf("%v", ents[i])
                if len(s) > 20 {
                    p.Printf("\t%s - %s...\n", memKeys[i], s[:20])
                }else{
                    p.Printf("\t%s - %s\n", memKeys[i], s)
                }
                if i >= 20 {
                    p.Printf("\t...(and %d ents)\n", size - i)
                    break
                }
            }
        })
    }

    key2Idx := make(map[*datastore.Key]int)
    cacheMissingKeys := make([]*datastore.Key, 0)
    for i := range ents {
        if ents[i] == nil {
            key2Idx[dsKeys[i]] = i
            cacheMissingKeys = append(cacheMissingKeys, dsKeys[i])
        }
    }
    cacheMissingSize := len(cacheMissingKeys)

    // Datastore access
    cacheMissingEnts := make([]*{{.Type}}, cacheMissingSize, cacheMissingSize)
    err := helper.GetMulti(ctx, cacheMissingKeys, cacheMissingEnts)
    if helper.IsDatastoreError(err) {
        // we return nil even some ents hits the cache.
        return nil, nil, err
    }

    if k.useDefaultIfNil {
        for i:=0; i < cacheMissingSize; i++ {
            if cacheMissingEnts[i] == nil {
                cacheMissingEnts[i] = k.New()
                cacheMissingEnts[i].{{.IDField}} = dsKeys[i].StringID() // TODO: Support non-string key as ID
            }
        }
    }

    // merge cacheMissingEnts with ents.
    for i := range cacheMissingKeys {
        entIdx := key2Idx[cacheMissingKeys[i]]
        ents[entIdx] = cacheMissingEnts[i]
    }

    // create a cache
    if !k.noCache {
        cacheEnts := make([]*{{.Type}}, 0)
        cacheKeys := make([]string, 0)
        for i := range ents {
            if ents[i] != nil {
                cacheEnts = append(cacheEnts, ents[i])
                cacheKeys = append(cacheKeys, memKeys[i])
            }
        }
        if len(cacheEnts) > 0 {
            if err := memcache.SetMulti(ctx, cacheKeys, cacheEnts); err != nil {
                logger.Warnf("Failed to create {{.Type}}) caches: %v", err)
            }
        }
    }

    logger.Debug(func(p *xlog.Printer){
        p.Printf(
            "{{.Type}}#GetMulti [Datastore] (UseDefault: %t, NoCache: %t)\n",
            k.useDefaultIfNil, k.noCache,
        )
        for i:=0; i < size; i++ {
            s := fmt.Sprintf("%v", ents[i])
            if len(s) > 20 {
                p.Printf("\t%s - %s...\n", dsKeys[i], s[:20])
            }else{
                p.Printf("\t%s - %s\n", dsKeys[i], s)
            }
            if i >= 20 {
                p.Printf("\t...(and %d ents)\n", size - i)
                break
            }
        }
    })
    return dsKeys, ents, nil
}

// MustGetMulti is like GetMulti but returns only values and panic if error happens.
func (k *{{.Type}}Kind) MustGetMulti(ctx context.Context, keys ...interface{}) []*{{.Type}} {
    _, v, err := k.GetMulti(ctx, keys...)
    if err != nil {
        panic(err)
    }
    return v
}

`
