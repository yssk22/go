// Code generated by "ent -type=Example"; DO NOT EDIT

package example

import (
	"fmt"
	helper "github.com/speedland/go/gae/datastore"
	"github.com/speedland/go/gae/datastore/ent"
	"github.com/speedland/go/gae/memcache"
	"github.com/speedland/go/x/xlog"
	"github.com/speedland/go/x/xtime"
	"golang.org/x/net/context"
	"google.golang.org/appengine/datastore"
)

func (ent *Example) NewKey(ctx context.Context) *datastore.Key {
	return helper.NewKey(ctx, "Example", ent.ID)
}

type ExampleKind struct {
	useDefaultIfNil bool
	noCache         bool
}

const ExampleKindLoggerKey = "ent.example"

func (k *ExampleKind) New() *Example {
	a := &Example{}
	a.Digit = 10
	a.Desc = "This is default value"
	a.CreatedAt = xtime.Now()
	a.DefaultTime = xtime.MustParse("2016-01-01T20:12:10Z")
	return a
}

func (k *ExampleKind) UseDefaultIfNil(b bool) *ExampleKind {
	k.useDefaultIfNil = b
	return k
}

// Get gets the kind entity from datastore
func (k *ExampleKind) Get(ctx context.Context, key interface{}) (*datastore.Key, *Example, error) {
	keys, ents, err := k.GetMulti(ctx, key)
	if err != nil {
		return nil, nil, err
	}
	return keys[0], ents[0], nil
}

// MustGet is like Get but returns only values and panic if error happens.
func (k *ExampleKind) MustGet(ctx context.Context, key interface{}) *Example {
	_, v, err := k.Get(ctx, key)
	if err != nil {
		panic(err)
	}
	return v
}

// GetMulti do Get with multiple keys
func (k *ExampleKind) GetMulti(ctx context.Context, keys ...interface{}) ([]*datastore.Key, []*Example, error) {
	logger := xlog.WithContext(ctx).WithKey(ExampleKindLoggerKey)
	size := len(keys)
	if size == 0 {
		return nil, nil, nil
	}
	var memKeys []string
	var dsKeys []*datastore.Key
	var ents []*Example

	dsKeys = make([]*datastore.Key, size, size)
	for i := range keys {
		dsKeys[i] = helper.NewKey(ctx, "Example", keys[i])
	}
	ents = make([]*Example, size, size)
	// Memcache access
	if !k.noCache {
		logger.Debugf("Trying to get entities from memcache...")
		memKeys = make([]string, size, size)
		for i := range dsKeys {
			memKeys[i] = ent.GetMemcacheKey(dsKeys[i])
		}
		err := memcache.GetMulti(ctx, memKeys, ents)
		if err == nil {
			// Hit caches on all keys!!
			return dsKeys, ents, nil
		}
		logger.Debug(func(p *xlog.Printer) {
			p.Println("Example#GetMulti [Memcache]")
			for i := 0; i < size; i++ {
				s := fmt.Sprintf("%v", ents[i])
				if len(s) > 20 {
					p.Printf("\t%s - %s...\n", memKeys[i], s[:20])
				} else {
					p.Printf("\t%s - %s\n", memKeys[i], s)
				}
				if i >= 20 {
					p.Printf("\t...(and %d ents)\n", size-i)
					break
				}
			}
		})
	}

	key2Idx := make(map[*datastore.Key]int)
	cacheMissingKeys := make([]*datastore.Key, 0)
	for i := range ents {
		if ents[i] == nil {
			key2Idx[dsKeys[i]] = i
			cacheMissingKeys = append(cacheMissingKeys, dsKeys[i])
		}
	}
	cacheMissingSize := len(cacheMissingKeys)

	// Datastore access
	cacheMissingEnts := make([]*Example, cacheMissingSize, cacheMissingSize)
	err := helper.GetMulti(ctx, cacheMissingKeys, cacheMissingEnts)
	if helper.IsDatastoreError(err) {
		// we return nil even some ents hits the cache.
		return nil, nil, err
	}

	if k.useDefaultIfNil {
		for i := 0; i < cacheMissingSize; i++ {
			if cacheMissingEnts[i] == nil {
				cacheMissingEnts[i] = k.New()
				cacheMissingEnts[i].ID = dsKeys[i].StringID() // TODO: Support non-string key as ID
			}
		}
	}

	// merge cacheMissingEnts with ents.
	for i := range cacheMissingKeys {
		entIdx := key2Idx[cacheMissingKeys[i]]
		ents[entIdx] = cacheMissingEnts[i]
	}

	// create a cache
	if !k.noCache {
		cacheEnts := make([]*Example, 0)
		cacheKeys := make([]string, 0)
		for i := range ents {
			if ents[i] != nil {
				cacheEnts = append(cacheEnts, ents[i])
				cacheKeys = append(cacheKeys, memKeys[i])
			}
		}
		if len(cacheEnts) > 0 {
			if err := memcache.SetMulti(ctx, cacheKeys, cacheEnts); err != nil {
				logger.Warnf("Failed to create Example) caches: %v", err)
			}
		}
	}

	logger.Debug(func(p *xlog.Printer) {
		p.Printf(
			"Example#GetMulti [Datastore] (UseDefault: %t, NoCache: %t)\n",
			k.useDefaultIfNil, k.noCache,
		)
		for i := 0; i < size; i++ {
			s := fmt.Sprintf("%v", ents[i])
			if len(s) > 20 {
				p.Printf("\t%s - %s...\n", dsKeys[i], s[:20])
			} else {
				p.Printf("\t%s - %s\n", dsKeys[i], s)
			}
			if i >= 20 {
				p.Printf("\t...(and %d ents)\n", size-i)
				break
			}
		}
	})
	return dsKeys, ents, nil
}

// MustGetMulti is like GetMulti but returns only values and panic if error happens.
func (k *ExampleKind) MustGetMulti(ctx context.Context, keys ...interface{}) []*Example {
	_, v, err := k.GetMulti(ctx, keys...)
	if err != nil {
		panic(err)
	}
	return v
}
